{
    "componentChunkName": "component---src-pages-post-tsx",
    "path": "/React/Hook의 종류",
    "result": {"data":{"markdownRemark":{"html":"<h1>Hook 이란?</h1>\n<p>함수형 컴포넌트에서 클래스 컴포넌트에서만 이용이 가능했던 State와 라이프 사이클 메서드를 이용할 수 있도록 도와주는 함수입니다.</p>\n<h1><a href=\"https://ko.reactjs.org/docs/hooks-state.html\">useState</a></h1>\n<p>함수형 컴포넌트안에서 상태를 정의할 때 사용되는 훅입니다.</p>\n<p>일반적으로 변수는 함수가 종료될 때 사라지지만, state변수는 React에 의해 사라지지 않습니다.</p>\n<h2>사용법</h2>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React, { useState } from &quot;react&quot;;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  const handleClickAdd = () =&gt; {\n    setCount(count + 1);\n  };\n\n  return (\n    &lt;div&gt;\n      &lt;span&gt;{count}&lt;/span&gt;\n      &lt;button onClick={handleClickAdd}&gt;+&lt;/button&gt;\n    &lt;/div&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>위의 코드 예시와 같이 선언은 <a href=\"https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment\">Destructuring(구조 분해 할당)</a>방식으로 const [상태값, 상태를 변경할 함수] = useState(초기값); 형식으로 선언할 수 있습니다.</p>\n<p>버튼을 클릭했을 때 setCount 함수를 실행하여 카운트값을 변경 시킵니다.</p>\n<h1><a href=\"https://ko.reactjs.org/docs/hooks-effect.html\">useEffect</a></h1>\n<p>useEffect는 함수를 인자로 받습니다.</p>\n<p>useEffect에 전달된 함수는 화면에 <strong>렌더링이 완료된 후</strong>에 실행됩니다. 또한 어떤 값이 변경되었을 때도 실행이 되어집니다.</p>\n<p>화면이 렌더링이 되기 전에 실행되어야 하는 함수가 있는 경우에 useLayoutEffect라는 훅을 제공합니다.</p>\n<h2>사용법</h2>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">import React, { useState, useEffect } from &quot;react&quot;;\n\nfunction Example() {\n  const [count, setCount] = useState(0);\n\n  // 아래의 코드는 타이틀이 `You clicked 0 times`이라고 변경 후 바뀌지 않는다.\n  useEffect(() =&gt; {\n    document.title = `You clicked ${count} times`;\n  });\n\n  // 아래의 코드는 타이틀이 `You clicked 0 times`이라고 변경 후 count값이 변경될 때 마다 타이틀이 업데이트 된다.\n  useEffect(() =&gt; {\n    document.title = `You clicked ${count} times`;\n  }, [count]);\n\n  return &lt;&gt;&lt;/&gt;;\n}</code>\n        </deckgo-highlight-code>\n<h1><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usereducer\">useReducer</a></h1>\n<p>useState의 대체 함수입니다. (state, action) => newState의 형태로 reducer를 받고 dispatch 메서드와 짝의 형태로 현재 state를 반환합니다.</p>\n<p>다수의 하윗값을 포함하는 복잡한 정적 로직을 만드는 경우나 다음 state가 이전 state에 의존적인 경우에 보통 useState보다 useReducer를 선호합니다.</p>\n<h2>사용법</h2>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const initialState = { count: 0 };\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case &quot;increment&quot;:\n      return { count: state.count + 1 };\n    case &quot;decrement&quot;:\n      return { count: state.count - 1 };\n    default:\n      throw new Error();\n  }\n}\n\nfunction Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  return (\n    &lt;&gt;\n      Count: {state.count}\n      &lt;button onClick={() =&gt; dispatch({ type: &quot;decrement&quot; })}&gt;-&lt;/button&gt;\n      &lt;button onClick={() =&gt; dispatch({ type: &quot;increment&quot; })}&gt;+&lt;/button&gt;\n    &lt;/&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<h1><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usereducer\">useCallback</a></h1>\n<p>useCallback은 콜백의 메모이제이션된 버전을 반환합니다.</p>\n<p>그 메모이제이션된 버전은 콜백의 의존성이 변경되었을 때에만 변경됩니다.</p>\n<p>참조의 동일성에 의존적인 최적화된 자식 컴포넌트에 콜백을 전달할 때 유용합니다.</p>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const memoizedCallback = useCallback(() =&gt; {\n  doSomething(a, b);\n}, [a, b]);</code>\n        </deckgo-highlight-code>\n<h1><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usememo\">useMemo</a></h1>\n<p>메모이제이션된 값을 반환합니다.</p>\n<p>useMemo는 의존성이 변경되었을 때에만 메모이제이션된 값만 다시 계산합니다.</p>\n<p>리엑트에서는 아래 내용과 같이 말합니다.</p>\n<blockquote>\n<p>useMemo는 성능 최적화를 위해 사용할 수는 있지만 의미상으로 보장이 있다고 생각하지는 마세요.<p>\n<p>useMemo를 사용하지 않고도 동작할 수 있도록 코드를 작성하고 그것을 추가하여 성능을 최적화하세요.<p>\n</blockquote>\n<p>useMemo와 useCallback을 난무해서 쓸 경우 해당값이 메모리에 캐싱이되어 가비지컬렉터가 재역할을 하지 못하게 됩니다.</p>\n<p>useMemo를 사용하는것은 상쇄할만큼 이익을 가져다 주지는 않습니다.</p>\n<p>그래서 리엑트에서 \"useMemo를 사용하지 않고도 동작할 수 있도록 코드를 작성하고 그것을 추가하여 성능을 최적화하세요.\" 라고 말을 하는 것 같습니다.</p>\n<h2>사용법</h2>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">const memoizedValue = useMemo(() =&gt; computeExpensiveValue(a, b), [a, b]);</code>\n        </deckgo-highlight-code>\n<h1><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#useref\">useRef</a></h1>\n<p>HTML 객체에 접근할 때 사용됩니다.</p>\n<h2>사용법</h2>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">function TextInputWithFocusButton() {\n  const inputEl = useRef(null);\n  const onButtonClick = () =&gt; {\n    // `current` points to the mounted text input element\n    inputEl.current.focus();\n  };\n  return (\n    &lt;&gt;\n      &lt;input ref={inputEl} type=&quot;text&quot; /&gt;\n      &lt;button onClick={onButtonClick}&gt;Focus the input&lt;/button&gt;\n    &lt;/&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<h1><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#uselayouteffect\">useLayoutEffect</a></h1>\n<p>useEffect의 경우에는 화면이 렌더링 된 뒤 호출이 되어지지만 useLayoutEffect는 화면이 그려지기 전에 실행되어지는 훅입니다.</p>\n<p>렌더링될 상태값이 렌더링이 되어지기 전에 상태값이 설정되어 있어야 할 경우 사용자 경험을 위해 useLayoutEffect를 사용한다면 좋은 사용자경험을 제공할 수 있습니다.</p>\n<h2>사용법</h2>\n<deckgo-highlight-code language=\"javascript\"  >\n          <code slot=\"code\">useLayoutEffect(() =&gt; {\n  // effect\n  return () =&gt; {\n    //clean up\n  };\n}, [count]);</code>\n        </deckgo-highlight-code>\n<h1>참고자료</h1>\n<ul>\n<li><a href=\"https://ko.reactjs.org/docs/hooks-reference.html\">React - Hook API 참고서</a></li>\n<li><a href=\"https://kentcdodds.com/blog/usememo-and-usecallback?ck_subscriber_id=1410661209\">Kent C. Dodds - When to useMemo and useCallback</a></li>\n</ul>","frontmatter":{"title":"[React] Hook의 종류","slug":"Hook의 종류","date":"2021.12.20","description":"React Hook의 종류에 대해 알 수 있고, 상황별로 어떤 Hook을 사용해야 하는지 알 수 있다."}}},"pageContext":{"id":"9fd02981-8aa4-540f-af0a-5224821b12e0"}},
    "staticQueryHashes": []}