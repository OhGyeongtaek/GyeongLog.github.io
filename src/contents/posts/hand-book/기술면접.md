---
slug: "기술면접"
date: "9999.11.19"
title: "[면접] 기술면접질문"
description: "기술면접질문"
category: "hand-book"
---

# [리엑트와 뷰의 차이점]

뷰를 사용할때 저희는 기본 컴포넌트 타입이 아닌 class 형식의 컴포넌트를 작성했는데요.
안그래도 많이 없는 뷰 커뮤니티에서 더 사용하지 않는 class를 사용하니까 에러가 발생했을 때 제가 볼 수 있는 커뮤니티가 많지 않았습니다.
반면에 리엑트를 사용했을 때는 사용자가 많아 에러가 발생했을때 검색을 하면 많은 부분 도움을 받을 수 있엇습니다.
그리고 컴포넌트안에서의 상태를 관리할 때 뷰같은 경우는 그냥 데이터를 넣으면 데이터가 실시간으로 바뀌는 반면,
리엑트는 setter를 이용하여 데이터를 바꿔야 하는 번거로움이 있습니다.
그리고 지금은 적응이 되서 괜찮지만 처음배울때는 훅을 사용할때 컴포넌트 최상단 로직에서 사용해야 하는 방식을 적응하는게 쉽지 않았습니다.

# [블로그를 왜 갯츠비로 만들었는지]

저는 일단 React로 기술 블로그를 만들고 싶었습니다.

하지만 리엑트는 CSR방식의 사이트라 SEO측변에서 불리합니다.

그래서 고민한 프레임워크는 갯츠비js와 넥스트js였는데요.

넥스트js 좋은 프레임워크지만, 저는 SSG방식으로 페이지가 사용자에게 빠르게 보여지고, 플러그인들이 많이 구현되어 있는 갯츠비JS를 선택하게 되었습니다.

# [프로세스와 스레드의 차이점은 무엇인가?]

GET과 POST의 차이는?

자바스크립트 관련 질문

실행 컨텍스트 🔥

# [클로저 란?]

함수가 선언될 당시의 렉시컬환경을 기억하고, 함수가 종료된 후에도 상위 스코프 체인 관계를 유지할 수 있는 구조를 말합니다.

# [클로저의 장점]

변수의 은닉화로 인하여 변수가 의도치않게 변경되는 상황을 방지합니다.

# [클로저를 어떻게 생성하나요]

변수를 하나 만들어 해당 변수 안에 변수를 선언하고, 해당 변수를 변경 및 접근 가능한 객체를 전달합니다.

# [this 란?]

자신이 속한 객체 또는 자신이 생성할 인스턴스를 가리키는 자기 참조 변수 입니다.

누가 실행했는지에 따라 달라지는데요.

만약 someone이라는 객체가 있고, someone에 후엠아이라는 변수에서 콘솔 this를 찍는다고 가정했을 때,

someone.후엠아이를 했을 경우 this는 someone이라는 객체가 나옵니다.

반면에 someone.후엠아이 라는 함수는 후엠아이 라는 변수에 넣고 실행 했을 경우

전역에서 실행했기 때문에 윈도우 객체가 나오게 됩니다.

# [프로토 타입]

프로토타입은 자바스크립트에서 객체에 함수나 상태값을 상속하는 방식입니다.

객체에서 메서드나 속성을 찾게 될 때 해당 인스턴스에서 확인 후 없다면 proto라는 속성을 통해 상속된 객체를 찾아 올라갑니다.

이는 해당 메서드나 속성을 찾기 위해 계속 프로토를 타고 올라가는데, 계속 올라가다가 Object 객체를 만나게 되면 멈추게 됩니다.

이렇게 타고 올라가는게 프로토타입 체인입니다.

# [빌트인 객체]

개발자가 모든 기능을 구현하지 않고, 편하게 개발할 수 있도록 자바스크립트에서 기본적으로 제공하는 객체입니다.

표준 빌트인 객체
ECMAScript 사양에 정의된 표준 객체

호스트 객체
ECMAScript는 정의되지 않았지만 자바스크립트 실행 환경에서 추가로 제공하는 객체

스코프 🔥

스코프란 "변수나 함수에 접근할 수 있는 범위." 라고 할 수 있습니다.

스코프는 2가지 타입이 있는데요. 하나는 전역스코프, 하나는 지역 스코프 입니다.

전역 스코프는 말 그대로 전역에 선언되어 있어 어느곳에서든지 접근이 가능합니다.

지역스코프는 해당 지역에서만 접근할 수 있어 지역을 벗어난 곳에서는 접근할 수 없습니다.

버츄얼돔

자바스크립트 돔의 경량화된 버전인데요.

# [렌더링 조건]

해당 컴포넌트 내부에서의 상태값이 변경되었을 경우.

해당 컴포넌트 외부에서 전달되는 props의 값이 변경되었을 경우.

# [이벤트 버블링, 캡처링]

버블링은 한 요소에 이벤트가 발생하면 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작합니다.

가장 최상단의 요소를 만날 때까지 이 과정이 반복되면서 요소 각각에 할당된 핸들러가 동작합니다.

캡처링은 버블링과 반대로 한 요소에 이벤트가 발생하면 조상 요소의 핸들러부터 동작해서 해당 요소를 만날때 까지 요소 각각의 할당된 핸들러가 동작합니다.

# [브라우저의 렌더링 과정]

우선 렌더 엔진이 HTML을 파싱하여 돔 노드로 이루어진 트리를 생성합니다.

그리고 css파일과 html에 inline 스타일로 작성된 스타일 코드를 파싱하여 cssom을 구성합니다.

돔 트리와 cssom을 결합하여 노드의 컨텐츠, 스타일 정보를 포함하는 렌더트리가 생성되게 됩니다.

랜더트리가 만들어지는 과정을 대략적으로 설명드리자면 도큐먼트 객체에서 각 노드를 순회하면서 각 노드에 맞는 cssom에서 찾아 규칙을 적용합니다.

이때 메타 태그나 display none 처럼 적용된 요소 같은 경우는 포함되어지지 않습니다.

렌더트리가 생성되면 이제 레이아웃 과정을 거치게 됩니다.

뷰포트 내에서 요소들의 정확한 위치와 크기를 계산하는 과정입니다.

박스 모델의 텍스트나 요소의 박스가 화면에서 차지하는 영역이나 여백이 계산됩니다.

레이아웃 과정을 통해 각 노드들이 어떻게 생겼고, 어디에 위치하는지 알게되면 화면에 그려지게 되는데 이를 페인트과정입니다.

# [이벤트 루프]

자바스크립트는 싱글쓰레드로 동작하기 때문에 한번에 여러가지 일을 하지 못합니다.

하지만 비동기 함수를 이용할때 한번에 여러가지 일을 하는것 처럼 보이죠.

자바스크립트는 비동기 함수를 만났을 때, 해당 함수를 Web API에 생성을 하게 됩니다.

Web API에서 해당 콜백함수가 실행준비가 완료되면 콜백함수를 콜백 큐에 넣게 됩니다.

이제 콜백 큐에서 콜 스택이 빌때까지 계속 보고 있다가 콜스택이 비게 되면 콜백함수를 콜스택에 넣어 실행하게 됩니다.

# [훅이란?]

# [버츄얼 머신이 뭔가요?]

# [훅이 뭔가요?]

# [promise를 왜 사용하나요?]

# [promise와 callback의 차이점]
